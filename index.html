<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Device Motion Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body { margin: 0; }
  </style>
</head>
<body>
  <script>
    // Initialize Three.js scene, camera, and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    let baseAlpha = 0;
    let baseBeta = 0;
    let baseGamma = 0;


    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xf0f0f0); // Pale grey
    renderer.shadowMap.enabled = true;  // Enable shadow rendering

    document.body.appendChild(renderer.domElement);

    // Create a phone-shaped tablet geometry
    const geometry = new THREE.BoxGeometry(0.8, 2, 0.08);
    const material = new THREE.MeshStandardMaterial({ color: 0x00dddd });
    material.side = THREE.DoubleSide;

    const phoneTablet = new THREE.Mesh(geometry, material);
    phoneTablet.castShadow = true;  // Cast shadows

    // Adding directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(0, 0, 10);
    directionalLight.castShadow = false;  // Cast shadows
    scene.add(directionalLight);

    // Highlight edges
    const edges = new THREE.EdgesGeometry(geometry);
    const edgeLines = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
    phoneTablet.add(edgeLines);

    scene.add(phoneTablet);
    camera.position.z = 4;

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // Update phoneTablet position and rotation based on device motion
    if (window.DeviceMotionEvent) {
      document.addEventListener('click', getAccel.bind(this), {once:true, capture:true});
      function getAccel(){
        DeviceMotionEvent.requestPermission().then(response => {
          if (response == 'granted') {
            window.addEventListener("devicemotion", function(event) {
              /*
              phoneTablet.position.x = event.accelerationIncludingGravity.x;
              phoneTablet.position.y = event.accelerationIncludingGravity.y;
              phoneTablet.position.z = event.accelerationIncludingGravity.z;
              */
              phoneTablet.position.x = event.acceleration.x;
              phoneTablet.position.y = event.acceleration.y;
              phoneTablet.position.z = event.acceleration.z;
            });
            window.addEventListener('deviceorientation', event => {
              const {alpha, beta, gamma} = event;

              Object.assign(phoneTablet.rotation, {
                z: THREE.Math.degToRad(alpha) - baseAlpha,
                x: THREE.Math.degToRad(beta) - baseBeta,
                y: THREE.Math.degToRad(gamma) - baseGamma
              });

              Object.assign(this.state.accelerometer, {
                alpha,
                beta,
                gamma
              });
              this.render();
            });
          }
        });
      }
    } else {
      alert("Sorry, your device doesn't support Device Motion");
    }

    document.addEventListener('click', function() {
      baseAlpha = phoneTablet.rotation.z;
      baseBeta = phoneTablet.rotation.x;
      baseGamma = phoneTablet.rotation.y;
    });

  </script>
  <script>
    class DeviceSpecs extends HTMLElement {
      constructor() {
        super();
        this.shadow = this.attachShadow({ mode: 'closed' });
        this.state = {};

        // Bind this to methods
        this.updateGeolocation = this._updateGeolocation.bind(this);
        this.updateConnection = this._updateConnection.bind(this);

        // Collect data and permissions
        this.initData();
      }

      async initData() {
        // Browser Information
        if (navigator.userAgentData && typeof navigator.userAgentData.getHighEntropyValues === 'function') {
          const highEntropyValues = await navigator.userAgentData.getHighEntropyValues([
            'architecture',
            'platform',
            'platformVersion'
          ]);
          this.state.architecture = highEntropyValues.architecture;
          this.state.platform = highEntropyValues.platform;
          this.state.platformVersion = highEntropyValues.platformVersion;
          this.state.userAgentInfo = {
            browserName: highEntropyValues.brands[0]?.brand,
            browserVersion: highEntropyValues.brands[0]?.version,
            osName: highEntropyValues.platform,
            osVersion: highEntropyValues.platformVersion,
          };
        } else {
          // Fallback to User-Agent string parsing
          const userAgent = navigator.userAgent;
          this.state.userAgentInfo = this.parseUserAgent(userAgent);
        }

        const { osName, osVersion } = this.state.userAgentInfo;
        const { os, device } = this.mapPlatformToHumanReadable(osName, osVersion, navigator.userAgent);
        this.state.humanReadableOS = os;
        this.state.deviceType = device;

        // Screen & Display
        const { availWidth, availHeight, orientation, colorDepth } = window.screen;
        this.state.screenInfo = { availWidth, availHeight, orientation, colorDepth };

        this.state.humanReadableOrientation = this.humanReadableOrientation(this.state?.screenInfo?.orientation);

        // Hardware Capabilities
        this.state.cpuCores = navigator.hardwareConcurrency || 'N/A';
        this.state.deviceMemory = navigator.deviceMemory || 'N/A';
        this.state.architecture = this.state.architecture ? this.state.architecture.toUpperCase() : 'N/A';

        // Network Information
        if ('connection' in navigator) {
          this.state.connectionType = (navigator.connection.type || navigator.connection.effectiveType || 'N/A').toLocaleUpperCase();
          this.state.roundTrip = navigator.connection.rtt || 'N/A';
          navigator.connection.addEventListener('change', this.updateConnection);
        }

        // Battery Status
        if ('getBattery' in navigator) {
          const battery = await navigator.getBattery();
          this.state.battery = {
            level: battery.level,
            charging: battery.charging,
            chargingTime: battery.chargingTime,
            dischargingTime: battery.dischargingTime
          };
        }

        // Geolocation
        if ('geolocation' in navigator) {
          navigator.geolocation.getCurrentPosition(
            this.updateGeolocation,
            () => { this.state.geoError = 'Permission Denied'; this.render(); },
            { timeout: 10000 }
          );
          navigator.geolocation.watchPosition(this.updateGeolocation);
        } else {
          this.state.geoError = 'N/A';
        }

        // Accelerometer
        if ('DeviceMotionEvent' in globalThis) {
          document.addEventListener('click', getAccel.bind(this), {once:true, capture:true});
          function getAccel(){
            DeviceMotionEvent.requestPermission().then(response => {
              if (response == 'granted') {
                this.state.accelerometer = {};
                 // in the alpha-beta-gamma axes (units in degrees)
                  window.addEventListener('deviceorientation', event => {
                    const {alpha, beta, gamma} = event;
                    Object.assign(this.state.accelerometer, {
                      alpha,
                      beta,
                      gamma
                    });
                    this.render();
                  });
                  window.addEventListener('devicemotion', event => {
                    Object.assign(this.state.accelerometer, event.accelerationIncludingGravity);
                    console.log(event.acceleration);
                    this.render();
                  });
                }
              });
          }
        } else {
          this.state.accelerometer = 'N/A';
        }

        // Initial Render
        this.render();
      }

      parseUserAgent(ua) {
        let browserName = 'Unknown';
        let browserVersion = 'Unknown';
        let osName = 'Unknown';
        let osVersion = 'Unknown';
        
        try {
          // Browser Detection
          if (ua.includes('Chrome')) {
            browserName = 'Chrome';
            const match = ua.match(/Chrome\/([\d.]+)/i);
            browserVersion = match ? match[1] : 'Unknown';
          } else if (ua.includes('Safari')) {
            browserName = 'Safari';
            const match = ua.match(/Version\/([\d.]+).*Safari/i);
            browserVersion = match ? match[1] : 'Unknown';
          } else if (ua.includes('Firefox')) {
            browserName = 'Firefox';
            const match = ua.match(/Firefox\/([\d.]+)/i);
            browserVersion = match ? match[1] : 'Unknown';
          }
        
          // OS Detection
          if (ua.includes('Mac OS') || ua.includes('Macintosh')) {
            osName = 'Mac OS';
            const match = ua.match(/Mac OS X ([\d_]+)/i);
            osVersion = match ? match[1].replace(/_/g, '.') : 'Unknown';
          } else if (ua.includes('Windows')) {
            osName = 'Windows';
            const match = ua.match(/Windows NT ([\d.]+)/i);
            osVersion = match ? match[1] : 'Unknown';
          } else if (ua.includes('Android')) {
            osName = 'Android';
            const match = ua.match(/Android ([\d.]+)/i);
            osVersion = match ? match[1] : 'Unknown';
          } else if (ua.includes('iPhone') || ua.includes('iPad')) {
            osName = 'iOS';
            const match = ua.match(/OS ([\d_]+) like Mac OS X/i);
            osVersion = match ? match[1].replace(/_/g, '.') : 'Unknown';
          }
        
        } catch (e) {
          console.error('Error in parsing user agent:', e);
        }
        
        return {
          browserName,
          browserVersion,
          osName,
          osVersion
        };
      }

        _updateGeolocation(position) {
          this.state.latitude = position.coords.latitude;
          this.state.longitude = position.coords.longitude;
          this.render();
        }

        _updateConnection() {
          this.state.connectionType = navigator.connection.type;
          this.state.roundTrip = navigator.connection.rtt;
          this.render();
        }

         humanReadableColors(depth) {
          let colors = Math.pow(2, depth);
          const suffixes = [' thousand', ' million', ' billion'];
          let i = 0;
          while (colors >= 1000 && i < suffixes.length) {
            colors /= 1000;
            i++;
          }
          return colors.toFixed(1) + (suffixes[i-1] || '') + ' colors';
        }

        mapPlatformToHumanReadable(platform, version, ua) {
        let os = 'Unknown', device = '';

        const getVersionPrefix = v => v.split('.')[0];

        if (/Mac/i.test(platform)) {
          os = { '10': 'macOS' }[getVersionPrefix(version)] || 'macOS';
        } else if (/Win/i.test(platform)) {
          os = { '10': 'Windows 10', '6': 'Windows 7/8.1' }[getVersionPrefix(version)] || 'Windows';
        } else if (/Linux/i.test(platform)) {
          os = 'Linux';
        } else if (/Android/i.test(platform)) {
          os = `Android ${version}`;
          device = ua.match(/; (.+?) Build\//)?.[1] || '';
        } else if (/iPhone|iPad/i.test(platform)) {
          os = `iOS ${version}`;
          device = /iPhone/.test(ua) ? 'iPhone' : 'iPad';
        }

        return { os, device };
      }

       humanReadableOrientation(orientation) {
        const angle = orientation?.angle ? ` (${orientation.angle}°)` : '';
        return {
          'landscape-primary': 'Landscape' + angle,
          'landscape-secondary': 'Landscape' + angle,
          'portrait-primary': 'Portrait' + angle,
          'portrait-secondary': 'Portrait' + angle
        }[orientation?.type] || 'N/A';
      }

      render() {
        const {
          userAgentInfo, architecture, platform, platformVersion, cpuCores, screenInfo,
          deviceMemory, connectionType, roundTrip,
          battery, latitude, longitude, accelerometer,
          geoError
        } = this.state;

        // You could map platformVersion to macOS code names here
        const macOsCodename = platformVersion === "13.6" ? "Sonoma" : "N/A";  // Just an example
        const cpuInfo = `${this.state.cpuCores} cores (${this.state.architecture})`;

        this.shadow.innerHTML = `
          <table>
            <!-- Browser Information -->
            <tr><th colspan="2">Browser Information</th></tr>
            <tr><td>Browser</td><td>${userAgentInfo.browserName || 'N/A'} ${userAgentInfo.browserVersion || ''}</td></tr>
            <tr><td>OS</td><td>${userAgentInfo.osName || 'N/A'} ${userAgentInfo.osVersion || ''} (${macOsCodename})</td></tr>
            <tr><td>OS</td><td>${this.state.humanReadableOS || 'N/A'}</td></tr>
            <tr><td>Device</td><td>${this.state.deviceType || 'N/A'}</td></tr>
            <!-- Screen & Display -->
            <tr><th colspan="2">Screen & Display</th></tr>
            <tr><td>Size</td><td>${screenInfo?.availWidth || 'N/A'} x ${screenInfo?.availHeight || 'N/A'} pixels</td></tr>
            <tr><td>Orientation</td><td>${this.state.humanReadableOrientation}</td></tr>
            <tr><td>Color Depth</td><td>${this.humanReadableColors(screenInfo?.colorDepth) || 'N/A'}</td></tr>

            <!-- Hardware Capabilities -->
            <tr><th colspan="2">Hardware Capabilities</th></tr>
            <tr><td>CPU Cores</td><td>${cpuInfo}</td></tr>
            <tr><td>Device Memory</td><td>${deviceMemory || 'N/A'} GB</td></tr>

            <!-- Network Information -->
            <tr><th colspan="2">Network Information</th></tr>
            <tr><td>Connection Type</td><td>${connectionType || 'N/A'}</td></tr>
            <tr><td>Ping</td><td>${Math.round(roundTrip/2) || 'N/A'} milliseconds</td></tr>

            <!-- Battery Status -->
            <tr><th colspan="2">Battery Status</th></tr>
            <tr><td>Level</td><td><meter value="${battery?.level || 0}" min="0" max="1"></meter></td></tr>
            <tr><td>Charging</td><td>${battery?.charging ? 'Yes' : 'No'}</td></tr>

            <!-- Geolocation -->
            <tr><th colspan="2">Geolocation</th></tr>
            <tr><td>Latitude</td><td>${latitude || geoError || 'N/A'}</td></tr>
            <tr><td>Longitude</td><td>${longitude || geoError || 'N/A'}</td></tr>

            <!-- Accelerometer -->
            <tr><th colspan="2">Accelerometer</th></tr>
            <tr><td>X</td><td>${accelerometer?.x?.toFixed(2) || 'N/A'} m/s²</td></tr>
            <tr><td>Y</td><td>${accelerometer?.y?.toFixed(2) || 'N/A'} m/s²</td></tr>
            <tr><td>Z</td><td>${accelerometer?.z?.toFixed(2) || 'N/A'} m/s²</td></tr>
          </table>
        `;
      }
    }
    // Register the custom element
    customElements.define('device-specs', DeviceSpecs);
  </script>
  <device-specs></device-specs>
</body>
</html>

